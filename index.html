<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Three.js avec fond CSS</title>
  <style>
    body {
      margin: 0;
      background: url("assets/textures/background.jpg") no-repeat center center fixed;
      background-size: cover;
    }

    button {
      font-family: Arial, sans-serif;
    }
  </style>

  <!-- Import ES Module Shims pour charger les modules ESM dans le navigateur -->
  <script
    async
    src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"
  ></script>

  <!-- Importmap pour utiliser THREE depuis un CDN -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.1/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.150.1/examples/jsm/"
    }
  }
  </script>
</head>

<body>
<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

  // --- INITIALISATION DE LA SCENE, CAMERA, RENDERER ---
  const scene = new THREE.Scene();

  const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
  );
  camera.position.set(4.61, 2.74, 8);

  const renderer = new THREE.WebGLRenderer({
    alpha: true,
    antialias: true
  });
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.setSize(window.innerWidth, window.innerHeight);
  // On force la transparence du clear :
  renderer.setClearColor(0x000000, 0);

  // Ajout de quelques optimisations
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.physicallyCorrectLights = false;

  document.body.appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);

  // Positions caméra possibles
  const cameraPositions = {
    farThirdPerson: {
        position: new THREE.Vector3(4.61, 2.74, 8),
        target: new THREE.Vector3(0, 0, 0)
    },
    firstPerson: {
        position: new THREE.Vector3(0, 0.5, 0),
        target: new THREE.Vector3(0, 0.5, -1)
    },
    closeThirdPerson: {
        position: new THREE.Vector3(0, 3, 4),
        target: new THREE.Vector3(0, 0, -5)
    }
  };

  let currentView = 'farThirdPerson';
  const viewOrder = ['farThirdPerson', 'firstPerson', 'closeThirdPerson'];

  const povButton = document.createElement('button');
  povButton.innerHTML = 'Camera: Distant View';
  povButton.style.cssText = `
    position: fixed;
    top: 20px;
    right: 20px;
    padding: 10px 20px;
    background: #0ea5e9;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    z-index: 1000;
    display: inline-block;
    margin-left: 10px;
    font-size: 16px;
  `;
  document.body.appendChild(povButton);

  const cycleButton = document.createElement('button');
  cycleButton.innerHTML = 'Toggle Day/Night Cycle';
  cycleButton.style.cssText = `
    position: fixed;
    top: 20px;
    right: 230px;
    padding: 10px 20px;
    background: #0ea5e9;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    z-index: 1000;
    display: inline-block;
    margin-left: 10px;
    font-size: 16px;
  `;
  document.body.appendChild(cycleButton);

  let cycleEnabled = true;
  let frozenTime = 0; 

  povButton.addEventListener('click', () => {
    const currentIndex = viewOrder.indexOf(currentView);
    const nextIndex = (currentIndex + 1) % viewOrder.length;
    currentView = viewOrder[nextIndex];
    
    if (currentView === 'farThirdPerson') {
        camera.position.copy(cameraPositions.farThirdPerson.position);
        camera.lookAt(cameraPositions.farThirdPerson.target);
        controls.reset(); 
    }
    
    let viewName;
    switch(currentView) {
        case 'farThirdPerson':
            viewName = 'Distant View';
            break;
        case 'firstPerson':
            viewName = 'First Person';
            break;
        case 'closeThirdPerson':
            viewName = 'Close Follow';
            break;
    }
    povButton.innerHTML = `Camera: ${viewName}`;
    controls.enabled = (currentView === 'farThirdPerson');
    povButton.blur();
  });

  cycleButton.addEventListener('click', () => {
    cycleEnabled = !cycleEnabled;
    cycleButton.innerHTML = cycleEnabled ? 'Pause Day/Night' : 'Resume Day/Night';
    if (!cycleEnabled) {
        frozenTime = time; // Store current time when pausing
    }
    updateCelestialBodiesVisibility();
    cycleButton.blur();
  });

  // --- CLASS BOX + COLLISION UTILS ---
  class Box extends THREE.Mesh {
    constructor({
      width,
      height,
      depth,
      color = '#00ff00',
      velocity = { x: 0, y: 0, z: 0 },
      position = { x: 0, y: 0, z: 0 },
      zAcceleration = false,
      collisionHeight
    }) {
      super(
        new THREE.BoxGeometry(width, height, depth),
        new THREE.MeshStandardMaterial({ color })
      );
      this.width = width;
      this.height = height;
      this.depth = depth;

      this.position.set(position.x, position.y, position.z);

      this.right = this.position.x + this.width / 2;
      this.left = this.position.x - this.width / 2;
      this.bottom = this.position.y - this.height / 2;
      this.top = this.position.y + this.height / 2;
      this.front = this.position.z + this.depth / 2;
      this.back = this.position.z - this.depth / 2;

      this.velocity = velocity;
      this.gravity = -0.002;
      this.zAcceleration = zAcceleration;
      this.canDoubleJump = true;
      this.isGrounded = false;
      this.collisionHeight = collisionHeight ?? height;
    }

    updateSides() {
      this.right = this.position.x + this.width / 2;
      this.left = this.position.x - this.width / 2;
      this.bottom = this.position.y - this.collisionHeight / 2;
      this.top = this.position.y + this.collisionHeight / 2;
      this.front = this.position.z + this.depth / 2;
      this.back = this.position.z - this.depth / 2;
    }

    update(ground) {
      this.updateSides();

      // Z acceleration
      if (this.zAcceleration) {
        if (this.isEnemy) {
          // enemis plus rapides
          this.velocity.z += 0.0009;
        } else {
          this.velocity.z += 0.0003;
        }
      }

      const nextX = this.position.x + this.velocity.x;
      const nextZ = this.position.z + this.velocity.z;
      let canMoveX = true;
      let canMoveZ = true;

      const originalX = this.position.x;
      const originalZ = this.position.z;

      // Collision sur X
      this.position.x = nextX;
      this.updateSides();
      if (
        boxCollision({ box1: this, box2: walls.left.collisionWall }) ||
        boxCollision({ box1: this, box2: walls.right.collisionWall })
      ) {
        canMoveX = false;
      }
      this.position.x = originalX;

      // Collision sur Z
      this.position.z = nextZ;
      this.updateSides();
      if (
        boxCollision({ box1: this, box2: walls.front.collisionWall }) ||
        boxCollision({ box1: this, box2: walls.back.collisionWall })
      ) {
        canMoveZ = false;
      }
      this.position.z = originalZ;

      // Applique le mouvement autorisé
      if (canMoveX) this.position.x = nextX;
      if (canMoveZ) this.position.z = nextZ;

      this.updateSides();
      this.applyGravity(ground);
    }

    applyGravity(ground) {
      this.velocity.y += this.gravity;
      if (boxCollision({ box1: this, box2: ground })) {
        const friction = 0.5;
        this.velocity.y *= friction;
        this.velocity.y = -this.velocity.y;
        this.isGrounded = true;
        this.canDoubleJump = true;
      } else {
        this.position.y += this.velocity.y;
        this.isGrounded = false;
      }
    }
  }

  function boxCollision({ box1, box2 }) {
    if (!box1 || !box2) return false;
    box1.updateMatrixWorld(true);
    box2.updateMatrixWorld(true);
    const b1 = new THREE.Box3().setFromObject(box1);
    const b2 = new THREE.Box3().setFromObject(box2);
    return b1.intersectsBox(b2);
  }

  // --- SOL ET MURS ---
  const ground = new Box({
    width: 10,
    height: 0.5,
    depth: 50,
    color: '#0369a1',
    position: { x: 0, y: -2, z: 0 }
  });
  ground.material.roughness = 0.4;
  ground.material.metalness = 0.2;
  ground.receiveShadow = true;
  scene.add(ground);

  const walls = {
    left: {
      collisionWall: new Box({
        width: 0.5,
        height: 10,
        depth: 50,
        color: '#ffffff',
        position: { x: -5.25, y: 5, z: 0 }
      }),
      visualWall: new Box({
        width: 0.5,
        height: 1.5,
        depth: 50,
        color: '#0369a1',
        position: { x: -5.25, y: -1, z: 0 }
      })
    },
    right: {
      collisionWall: new Box({
        width: 0.5,
        height: 10,
        depth: 50,
        color: '#ffffff',
        position: { x: 5.25, y: 5, z: 0 }
      }),
      visualWall: new Box({
        width: 0.5,
        height: 1.5,
        depth: 50,
        color: '#0369a1',
        position: { x: 5.25, y: -1, z: 0 }
      })
    },
    front: {
      collisionWall: new Box({
        width: 10,
        height: 10,
        depth: 0.5,
        color: '#ffffff',
        position: { x: 0, y: 5, z: 25 }
      }),
      visualWall: new Box({
        width: 10,
        height: 1.5,
        depth: 0.5,
        color: '#0369a1',
        position: { x: 0, y: -1, z: 25 }
      })
    },
    back: {
      collisionWall: new Box({
        width: 10,
        height: 10,
        depth: 0.5,
        color: '#ffffff',
        position: { x: 0, y: 5, z: -25 }
      }),
      visualWall: new Box({
        width: 10,
        height: 1.5,
        depth: 0.5,
        color: '#0369a1',
        position: { x: 0, y: -1, z: -25 }
      })
    }
  };

  Object.values(walls).forEach(({ collisionWall, visualWall }) => {
    collisionWall.material.visible = false;
    scene.add(collisionWall);
    scene.add(visualWall);
  });

  // --- JOUR / NUIT ---
  const daySky = new THREE.Color(0x87ceeb);
  const nightSky = new THREE.Color(0x0a1931);
  const dayGround = new THREE.Color(0x0369a1);
  const nightGround = new THREE.Color(0x023761);

  // LUMIERES
  const sunLight = new THREE.DirectionalLight(0xfff2d6, 2.5);
  const moonLight = new THREE.DirectionalLight(0xb0c4de, 0);
  const ambientDay = new THREE.AmbientLight(0x404040, 0.7);
  const ambientNight = new THREE.AmbientLight(0x1a2036, 0.25);

  sunLight.position.set(10, 50, 10);
  sunLight.castShadow = true;
  sunLight.shadow.mapSize.width = 2048;
  sunLight.shadow.mapSize.height = 2048;
  sunLight.shadow.bias = -0.0001;
  sunLight.shadow.normalBias = 0.02;
  sunLight.shadow.camera.near = 0.1;
  sunLight.shadow.camera.far = 150;
  sunLight.shadow.camera.left = -30;
  sunLight.shadow.camera.right = 30;
  sunLight.shadow.camera.top = 30;
  sunLight.shadow.camera.bottom = -30;

  moonLight.castShadow = true;
  moonLight.shadow.mapSize.width = 1024;
  moonLight.shadow.mapSize.height = 1024;

  scene.add(sunLight, moonLight, ambientDay, ambientNight);

  // Soleil & Lune
  const sunGeometry = new THREE.SphereGeometry(3, 32, 32);
  const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffdd00 });
  const sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
  sunMesh.position.copy(sunLight.position);

  const moonGeometry = new THREE.SphereGeometry(2, 32, 32);
  const moonMaterial = new THREE.MeshBasicMaterial({ color: 0xdddddd });
  const moonMesh = new THREE.Mesh(moonGeometry, moonMaterial);
  moonMesh.position.copy(moonLight.position);

  scene.add(sunMesh, moonMesh);

  // Lumières ponctuelles de nuit
  const nightLights = [];
  const nightLightPositions = [
      { x: -5, z: -10 },
      { x: 5, z: -10 },
      { x: -5, z: 0 },
      { x: 5, z: 0 },
      { x: 0, z: -20 },
      { x: -8, z: -15 },
      { x: 8, z: -15 },
      { x: 0, z: -5 }
  ];
  nightLightPositions.forEach(pos => {
      const pointLight = new THREE.PointLight(0x6495ED, 0, 12);
      pointLight.position.set(pos.x, 1, pos.z);
      pointLight.decay = 2;
      scene.add(pointLight);
      nightLights.push(pointLight);
  });

  // Glow autour de la lune
  const moonGlow = new THREE.PointLight(0x6495ED, 0, 40);
  moonGlow.decay = 2;
  scene.add(moonGlow);

  const dayLength = 20000;
  let time = 0;

  camera.position.z = 5;
  console.log(ground.top);

  // --- CONTROLES CLAVIER ---
  const keys = {
    a: { pressed: false },
    d: { pressed: false },
    s: { pressed: false },
    w: { pressed: false }
  };

  window.addEventListener('keydown', (event) => {
    switch (event.code) {
      case 'KeyA':
        keys.a.pressed = true;
        break;
      case 'KeyD':
        keys.d.pressed = true;
        break;
      case 'KeyS':
        keys.s.pressed = true;
        break;
      case 'KeyW':
        keys.w.pressed = true;
        break;
      case 'Space':
        if (robotModel && robotModel.userData.isGrounded) {
          robotModel.userData.velocityY = 0.1;
        } else if (robotModel && robotModel.userData.canDoubleJump) {
          robotModel.userData.velocityY = 0.1;
          robotModel.userData.canDoubleJump = false;
        }
        break;
      case 'KeyP':
        povButton.click();
        break;
      case 'KeyN':
        cycleButton.click();
        break;
    }
  });

  window.addEventListener('keyup', (event) => {
    switch (event.code) {
      case 'KeyA':
        keys.a.pressed = false;
        break;
      case 'KeyD':
        keys.d.pressed = false;
        break;
      case 'KeyS':
        keys.s.pressed = false;
        break;
      case 'KeyW':
        keys.w.pressed = false;
        break;
    }
  });

  const enemies = [];
  let frames = 0;
  let spawnRate = 120;

  // --- BOUTONS ET MENUS (POV, START, ETC.) ---
  const icons = {
      distantView: `<svg viewBox="0 0 24 24" width="24" height="24" fill="white">
          <path d="M12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm8.94 3c-.46-4.17-3.77-7.48-7.94-7.94V1h-2v2.06C6.83 3.52 3.52 6.83 3.06 11H1v2h2.06c.46 4.17 3.77 7.48 7.94 7.94V23h2v-2.06c4.17-.46 7.48-3.77 7.94-7.94H23v-2h-2.06zM12 19c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"/>
      </svg>`,
      firstPerson: `<svg viewBox="0 0 24 24" width="24" height="24" fill="white">
          <path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"/>
      </svg>`,
      closeFollow: `<svg viewBox="0 0 24 24" width="24" height="24" fill="white">
          <path d="M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1S9.9 9.16 9.9 8s.94-2.1 2.1-2.1M12 14.9c2.97 0 6.1 1.46 6.1 2.1v1.1H5.9V17c0-.64 3.13-2.1 6.1-2.1M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"/>
      </svg>`
  };

  function createPOVButtons(container, callback) {
      const buttonContainer = document.createElement('div');
      buttonContainer.style.cssText = `
          display: flex;
          gap: 10px;
          margin-bottom: 20px;
      `;
      const buttonStyles = `
          padding: 15px;
          background: #0ea5e9;
          border: 2px solid transparent;
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.3s;
      `;
      ['distantView', 'firstPerson', 'closeFollow'].forEach((view, index) => {
          const button = document.createElement('button');
          button.innerHTML = icons[view];
          button.style.cssText = buttonStyles;
          button.title = view === 'distantView' ? 'Distant View' : 
                        view === 'firstPerson' ? 'First Person' : 'Close Follow';
          button.addEventListener('mouseover', () => {
              button.style.background = '#0284c7';
          });
          button.addEventListener('mouseout', () => {
              button.style.background = '#0ea5e9';
          });
          button.addEventListener('click', () => {
              callback(viewOrder[index]);
              buttonContainer.querySelectorAll('button').forEach(btn => {
                  btn.style.border = '2px solid transparent';
              });
              button.style.border = '2px solid white';
          });
          buttonContainer.appendChild(button);
      });
      container.appendChild(buttonContainer);
      return buttonContainer;
  }

  function createGameOverMenu() {
      const gameOverMenu = document.createElement('div');
      gameOverMenu.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.9);
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          gap: 20px;
          z-index: 2000;
      `;
      const title = document.createElement('h1');
      title.textContent = 'Game Over';
      title.style.cssText = `
          color: white;
          font-family: Arial, sans-serif;
          font-size: 48px;
          margin-bottom: 30px;
      `;
      const scoreDisplay = document.createElement('p');
      scoreDisplay.textContent = `Your Score: ${score}`;
      scoreDisplay.style.cssText = `
          color: white;
          font-family: Arial, sans-serif;
          font-size: 24px;
          margin-bottom: 20px;
      `;
      const buttonStyles = `
          padding: 15px 30px;
          font-size: 18px;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          transition: background 0.3s;
          margin: 10px;
      `;
      const restartButton = document.createElement('button');
      restartButton.textContent = 'Restart Game';
      restartButton.style.cssText = buttonStyles + 'background: #22c55e;';
      const settingsButton = document.createElement('button');
      settingsButton.textContent = 'Change Settings';
      settingsButton.style.cssText = buttonStyles + 'background: #0ea5e9;';

      restartButton.addEventListener('mouseover', () => {
          restartButton.style.background = '#16a34a';
      });
      restartButton.addEventListener('mouseout', () => {
          restartButton.style.background = '#22c55e';
      });
      settingsButton.addEventListener('mouseover', () => {
          settingsButton.style.background = '#0284c7';
      });
      settingsButton.addEventListener('mouseout', () => {
          settingsButton.style.background = '#0ea5e9';
      });

      gameOverMenu.appendChild(title);
      gameOverMenu.appendChild(scoreDisplay);
      gameOverMenu.appendChild(restartButton);
      gameOverMenu.appendChild(settingsButton);

      restartButton.addEventListener('click', () => {
          resetGame();
          gameOverMenu.remove();
      });
      settingsButton.addEventListener('click', () => {
          gameOverMenu.remove();
          showStartMenu();
      });

      return gameOverMenu;
  }

  // --- VARIABLES GLOBALES ---
  let currentAnimationFrame = null;
  let robotModel;
  let robotMixer;
  let robotActions = {};
  let robotCollider;
  let isModelReady = false;
  let gameStarted = false;

  // --- CHARGE LE MODELE GLTF ---
  const loader = new GLTFLoader();
  loader.load('./assets/models/RobotExpressive.glb', (gltf) => {
      console.log('Model loaded successfully');
      robotModel = gltf.scene;
      robotModel.scale.set(0.3, 0.3, 0.3);
      robotModel.traverse((node) => {
          if (node.isMesh) {
              node.castShadow = true;
              node.receiveShadow = true;
          }
      });
      robotModel.castShadow = true;
      robotModel.position.set(0, 0, 0);
      robotModel.rotation.y = Math.PI;
      robotModel.userData = { velocityY: 0, isGrounded: false, canDoubleJump: true };
      scene.add(robotModel);

      // Collider invisible
      const colliderSize = { width: 0.8, height: 1.8, depth: 0.8 };
      robotCollider = new Box({
          width: colliderSize.width,
          height: colliderSize.height,
          depth: colliderSize.depth,
          color: '#ff0000',
          position: {
              x: robotModel.position.x,
              y: robotModel.position.y + colliderSize.height/2 - 0.2,
              z: robotModel.position.z
          }
      });
      robotCollider.material.visible = false;
      scene.add(robotCollider);

      // Animations
      robotMixer = new THREE.AnimationMixer(robotModel);
      gltf.animations.forEach((clip) => {
          robotActions[clip.name] = robotMixer.clipAction(clip);
      });
      console.log('Loaded robot actions:', robotActions);
      if (robotActions['Idle']) {
          robotActions['Idle'].play();
      } else {
          console.warn('Idle animation not found.');
      }
      robotModel.traverse((child) => {
          if (child.isMesh) {
              child.geometry.computeBoundingBox();
          }
      });

      showStartMenu();
      isModelReady = true;
  }, undefined, (error) => {
      console.error('An error occurred while loading the model:', error);
  });

  // --- MOUVEMENTS PERSONNAGE ---
  function updateRobotMovement() {
    if (!robotModel || !robotCollider) return;
    const velocity = new THREE.Vector3(0, 0, 0);
    let isMoving = false;

    if (keys.a.pressed) { velocity.x = -0.05; isMoving = true; }
    if (keys.d.pressed) { velocity.x =  0.05; isMoving = true; }
    if (keys.s.pressed) { velocity.z =  0.05; isMoving = true; }
    if (keys.w.pressed) { velocity.z = -0.05; isMoving = true; }

    // RobotCollider suit la position du robot
    robotCollider.position.x = robotModel.position.x;
    robotCollider.position.z = robotModel.position.z;
    robotCollider.position.y = robotModel.position.y + robotCollider.height/2 - 0.2;

    const nextX = robotCollider.position.x + velocity.x;
    const nextZ = robotCollider.position.z + velocity.z;
    let canMoveX = true, canMoveZ = true;
    const originalX = robotCollider.position.x;
    const originalZ = robotCollider.position.z;

    // Collision en X
    robotCollider.position.x = nextX;
    robotCollider.updateSides();
    if (boxCollision({ box1: robotCollider, box2: walls.left.collisionWall }) ||
        boxCollision({ box1: robotCollider, box2: walls.right.collisionWall })) {
      canMoveX = false;
    }
    robotCollider.position.x = originalX;

    // Collision en Z
    robotCollider.position.z = nextZ;
    robotCollider.updateSides();
    if (boxCollision({ box1: robotCollider, box2: walls.front.collisionWall }) ||
        boxCollision({ box1: robotCollider, box2: walls.back.collisionWall })) {
      canMoveZ = false;
    }
    robotCollider.position.z = originalZ;

    if (canMoveX) robotModel.position.x += velocity.x;
    if (canMoveZ) robotModel.position.z += velocity.z;

    // Gravité
    robotModel.userData.velocityY += -0.002;
    robotModel.position.y += robotModel.userData.velocityY;
    robotCollider.position.y += robotModel.userData.velocityY;

    if (boxCollision({ box1: robotCollider, box2: ground })) {
      robotModel.userData.velocityY = 0;
      robotModel.position.y = ground.top + 0.2;
      robotModel.userData.isGrounded = true;
      robotModel.userData.canDoubleJump = true;
    } else {
      robotModel.userData.isGrounded = false;
    }

    robotCollider.position.x = robotModel.position.x;
    robotCollider.position.z = robotModel.position.z;
    robotCollider.position.y = robotModel.position.y + robotCollider.height/2 - 0.2;

    // Rotation selon direction
    if (isMoving) {
      const angle = Math.atan2(velocity.x, velocity.z);
      robotModel.rotation.y = angle;
    }

    // Animations
    if (robotMixer) {
        if (isMoving) {
            if (robotActions['Running'] && !robotActions['Running'].isRunning()) {
                robotActions['Idle']?.stop();
                robotActions['Running'].play();
            }
        } else {
            if (robotActions['Idle'] && !robotActions['Idle'].isRunning()) {
                robotActions['Running']?.stop();
                robotActions['Idle'].play();
            }
        }
        // On met à jour le mixer
        robotMixer.update(0.016);
    }
  }

  // --- POOLING DES ENNEMIS ---
  const enemyPool = [];
  const MAX_ENEMIES = 50;
  const ENEMY_CLEANUP_DISTANCE = 30;
  const ENEMY_STUCK_THRESHOLD = 5;

  function getEnemyFromPool() {
    if (enemyPool.length > 0) {
      const enemy = enemyPool.pop();
      const xPos = (Math.random() - 0.5) * 8;
      enemy.position.set(xPos, 0, -20);
      enemy.velocity.z = 0.015 + Math.random() * 0.01;
      enemy.velocity.x = (Math.random() - 0.5) * 0.02;
      enemy.userData.spawnTime = performance.now();
      enemy.userData.lastZPosition = -20;
      enemy.userData.stuckTime = 0;
      enemy.isEnemy = true;
      enemy.visible = true;
      scene.add(enemy);
      return enemy;
    }
    const xPos = (Math.random() - 0.5) * 8;
    const shaderUniforms = {
      time: { value: 0 },
      glow: { value: 0.6 }
    };
    const enemy = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.ShaderMaterial({
        uniforms: shaderUniforms,
        vertexShader: redGlowVertexShader,
        fragmentShader: redGlowFragmentShader,
        transparent: true,
        side: THREE.DoubleSide
      })
    );
    enemy.castShadow = true;
    enemy.receiveShadow = false;
    enemy.position.set(xPos, 0, -20);
    enemy.isEnemy = true;
    enemy.width = 1;
    enemy.height = 1;
    enemy.depth = 1;
    enemy.velocity = {
      x: (Math.random() - 0.5) * 0.02,
      y: 0,
      z: 0.015 + Math.random() * 0.01
    };
    enemy.gravity = -0.002;
    enemy.zAcceleration = true;
    enemy.updateSides = Box.prototype.updateSides;
    enemy.applyGravity = Box.prototype.applyGravity;
    enemy.update = Box.prototype.update;
    enemy.shaderUniforms = shaderUniforms;
    enemy.userData.spawnTime = performance.now();
    enemy.userData.lastZPosition = -20;
    enemy.userData.stuckTime = 0;
    scene.add(enemy);
    return enemy;
  }

  function cleanupEnemies() {
    const currentTime = performance.now();
    for (let i = enemies.length - 1; i >= 0; i--) {
      const enemy = enemies[i];
      if (enemy.position.z > ENEMY_CLEANUP_DISTANCE || enemy.position.y < -10) {
        scene.remove(enemy);
        enemy.visible = false;
        enemyPool.push(enemy);
        enemies.splice(i, 1);
        continue;
      }
      if (Math.abs(enemy.position.z - enemy.userData.lastZPosition) < 0.01) {
        enemy.userData.stuckTime += 1/60;
        if (enemy.userData.stuckTime > ENEMY_STUCK_THRESHOLD) {
          scene.remove(enemy);
          enemy.visible = false;
          enemyPool.push(enemy);
          enemies.splice(i, 1);
          continue;
        }
      } else {
        enemy.userData.stuckTime = 0;
        enemy.userData.lastZPosition = enemy.position.z;
      }
      const lifespan = (currentTime - enemy.userData.spawnTime) / 1000;
      if (lifespan > 30) {
        scene.remove(enemy);
        enemy.visible = false;
        enemyPool.push(enemy);
        enemies.splice(i, 1);
      }
    }
  }

  // --- BOUCLE D'ANIMATION ---
  function animate() {
    currentAnimationFrame = requestAnimationFrame(animate);
    if (gameStarted) {
        updateRobotMovement();
    }
    if (gameStarted) {
      updateRobotMovement();
      cleanupEnemies();
      for (let i = 0; i < enemies.length; i++) {
        const enemy = enemies[i];
        enemy.update(ground);
        if (Math.abs(enemy.position.z - robotModel.position.z) < 5) {
          if (boxCollision({ box1: robotCollider, box2: enemy })) {
            gameStarted = false;
            stopScoreCounter();
            cancelAnimationFrame(currentAnimationFrame);
            document.body.appendChild(createGameOverMenu());
            return;
          }
        }
      }
      if (frames % spawnRate === 0 && enemies.length < MAX_ENEMIES) {
        if (spawnRate > 40) spawnRate -= 10;
        const newEnemy = getEnemyFromPool();
        if (newEnemy) enemies.push(newEnemy);
        if (spawnRate < 80 && Math.random() > 0.5) {
          const extraEnemy = getEnemyFromPool();
          if (extraEnemy) enemies.push(extraEnemy);
        }
      }
      frames++;
      if (cycleEnabled) {
        time += 16;
        if (frames % 2 === 0) {
          updateDayNightCycle();
        }
      }
    }
    updateCameraPosition();
    renderer.render(scene, camera);

    // On met à jour le shader time
    for (let i = 0; i < enemies.length; i++) {
      const enemy = enemies[i];
      if (enemy.shaderUniforms) {
        enemy.shaderUniforms.time.value = time * 0.001;
        const distanceToPlayer = enemy.position.distanceTo(robotModel.position);
        if (distanceToPlayer < 10) {
          enemy.shaderUniforms.glow.value = THREE.MathUtils.mapLinear(
            distanceToPlayer, 2, 10, 1.0, 0.6
          );
        }
      }
    }
  }

  // --- FONCTION UPDATE JOUR / NUIT ---
  function updateDayNightCycle() {
    if (!cycleEnabled) return;
    const dayTime = (time % dayLength) / dayLength;
    const angle = dayTime * Math.PI * 2;
    const orbitRadius = 40;
    const heightOffset = 50;
    sunLight.position.x = Math.cos(angle) * orbitRadius;
    sunLight.position.y = Math.sin(angle) * orbitRadius / 2 + heightOffset;
    sunLight.position.z = Math.sin(angle) * (orbitRadius / 2);
    sunMesh.position.copy(sunLight.position);

    const sunIntensity = Math.max(0, Math.sin(angle));
    const moonIntensity = Math.max(0, -Math.sin(angle));
    sunLight.intensity = sunIntensity * 2.5;
    moonLight.intensity = moonIntensity * 1.2;

    moonLight.position.x = Math.cos(angle + Math.PI) * orbitRadius;
    moonLight.position.y = Math.sin(angle + Math.PI) * orbitRadius / 2 + heightOffset;
    moonLight.position.z = Math.sin(angle + Math.PI) * (orbitRadius / 2);
    moonMesh.position.copy(moonLight.position);
    moonGlow.position.copy(moonLight.position);

    for (let i = 0; i < nightLights.length; i++) {
      if (i < nightLights.length / 2) {
        nightLights[i].intensity = Math.log(moonIntensity * 9 + 1) * 0.8;
      } else {
        nightLights[i].intensity = 0;
      }
    }
    moonGlow.intensity = moonIntensity * 1.5;
  }

  function updateCelestialBodiesVisibility() {
    if (!cycleEnabled) {
      sunLight.position.set(0, 50, 50);
      moonLight.position.set(0, -1000, 0);
      sunMesh.visible = false;
      moonMesh.visible = false;
      moonGlow.visible = false;
      sunLight.target.position.set(0, 0, 0);
      scene.add(sunLight.target);
      sunLight.intensity = 2.5;
      moonLight.intensity = 0;
      sunLight.shadow.camera.far = 150;
      sunLight.updateMatrixWorld();
      sunLight.shadow.camera.updateProjectionMatrix();
    } else {
      sunMesh.visible = true;
      moonMesh.visible = true;
      moonGlow.visible = true;
      const dayTime = (time % dayLength) / dayLength;
      const angle = dayTime * Math.PI * 2;
      const orbitRadius = 40;
      const heightOffset = 50;
      sunLight.position.x = Math.cos(angle) * orbitRadius;
      sunLight.position.y = Math.sin(angle) * orbitRadius / 2 + heightOffset;
      sunLight.position.z = Math.sin(angle) * (orbitRadius / 2);
      sunMesh.position.copy(sunLight.position);
      moonLight.position.x = Math.cos(angle + Math.PI) * orbitRadius;
      moonLight.position.y = Math.sin(angle + Math.PI) * orbitRadius / 2 + heightOffset;
      moonLight.position.z = Math.sin(angle + Math.PI) * (orbitRadius / 2);
      moonMesh.position.copy(moonLight.position);
      moonGlow.position.copy(moonLight.position);
    }
  }

  function updateCameraPosition() {
    if (currentView === 'firstPerson') {
      camera.position.copy(robotModel.position);
      camera.position.y += 1.5;
      camera.rotation.set(0, 0, 0);
      camera.lookAt(new THREE.Vector3(
        robotModel.position.x,
        robotModel.position.y + 1.5,
        robotModel.position.z - 1
      ));
    } else if (currentView === 'closeThirdPerson') {
      const idealOffset = new THREE.Vector3(0, 3, 4);
      const idealLookat = new THREE.Vector3(0, 0, -5);
      const offset = idealOffset.clone();
      offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0);
      offset.add(robotModel.position);
      const target = idealLookat.clone();
      target.applyAxisAngle(new THREE.Vector3(0, 1, 0), 0);
      target.add(robotModel.position);
      camera.position.lerp(offset, 0.1);
      camera.lookAt(target);
    }
  }

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  });

  function resetGame() {
    console.log('Resetting game...');
    stopScoreCounter();
    startScoreCounter();
    if (currentAnimationFrame) {
        cancelAnimationFrame(currentAnimationFrame);
    }
    Object.keys(keys).forEach(key => { keys[key].pressed = false; });
    enemies.forEach(enemy => {
      scene.remove(enemy);
      enemy.visible = false;
      enemyPool.push(enemy);
    });
    enemies.length = 0;
    spawnRate = 20;
    frames = 0;
    if (currentView === 'farThirdPerson') {
        camera.position.copy(cameraPositions.farThirdPerson.position);
        camera.lookAt(cameraPositions.farThirdPerson.target);
        controls.reset();
    }
    if (robotModel) {
        robotModel.position.set(0, 0, 0);
        robotModel.userData.velocityY = 0;
    }
    updateCelestialBodiesVisibility();
    gameStarted = true;
    console.log('Game started, beginning animation loop');
    animate();
  }

  function showStartMenu() {
      const existingMenu = document.getElementById('startGameMenu');
      if (existingMenu) {
          document.body.removeChild(existingMenu);
      }
      const startMenu = document.createElement('div');
      startMenu.id = 'startGameMenu';
      startMenu.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.8);
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          gap: 20px;
          z-index: 2000;
      `;
      const menuTitle = document.createElement('h1');
      menuTitle.textContent = 'Game Settings';
      menuTitle.style.cssText = `
          color: white;
          font-family: Arial, sans-serif;
          margin-bottom: 30px;
      `;
      startMenu.appendChild(menuTitle);

      let selectedView = 'farThirdPerson';
      createPOVButtons(startMenu, (view) => { selectedView = view; });

      const cycleToggle = document.createElement('div');
      cycleToggle.style.cssText = `
          display: flex;
          align-items: center;
          gap: 10px;
          margin-bottom: 20px;
      `;
      const cycleCheckbox = document.createElement('input');
      cycleCheckbox.type = 'checkbox';
      cycleCheckbox.id = 'cycleToggle';
      cycleCheckbox.style.transform = 'scale(1.5)';
      const cycleLabel = document.createElement('label');
      cycleLabel.htmlFor = 'cycleToggle';
      cycleLabel.textContent = 'Enable Day/Night Cycle';
      cycleLabel.style.color = 'white';
      cycleToggle.appendChild(cycleCheckbox);
      cycleToggle.appendChild(cycleLabel);
      startMenu.appendChild(cycleToggle);

      const startButton = document.createElement('button');
      startButton.textContent = 'Start Game';
      startButton.style.cssText = `
          padding: 15px 30px;
          font-size: 18px;
          background: #22c55e;
          color: white;
          border: none;
          border-radius: 5px;
          cursor: pointer;
          transition: background 0.3s;
      `;
      startButton.addEventListener('click', () => {
          if (gameStarted) return;
          console.log('Start Game button clicked');
          if (!isModelReady) {
              alert('Still loading the 3D model, please wait...');
              startButton.disabled = false;
              startButton.style.opacity = '1';
              startButton.textContent = 'Start Game';
              return;
          }
          startButton.disabled = true;
          startButton.style.opacity = '0.5';
          startButton.textContent = 'Starting...';
          if (!robotModel) {
              console.warn('Using fallback cube instead of 3D model');
              robotModel = new Box({
                  width: 1,
                  height: 1,
                  depth: 1,
                  color: '#00ff00',
                  velocity: { x: 0, y: -0.01, z: 0 }
              });
              robotModel.userData = { velocityY: 0, isGrounded: false, canDoubleJump: true };
              scene.add(robotModel);
          }
          currentView = selectedView;
          cycleEnabled = cycleCheckbox.checked;
          cycleButton.innerHTML = cycleEnabled ? 'Pause Day/Night' : 'Resume Day/Night';
          controls.enabled = (currentView === 'farThirdPerson');

          if (!cycleEnabled) {
            sunLight.position.set(0, 50, 50);
            sunLight.target.position.set(0, 0, 0);
            sunLight.shadow.camera.updateProjectionMatrix();
          }
          gameStarted = true;
          console.log('Starting game, gameStarted =', gameStarted);
          if (document.getElementById('startGameMenu')) {
              document.body.removeChild(document.getElementById('startGameMenu'));
          }
          setTimeout(() => { resetGame(); }, 50);
      });
      startButton.addEventListener('mouseover', () => {
          startButton.style.background = '#16a34a';
      });
      startButton.addEventListener('mouseout', () => {
          startButton.style.background = '#22c55e';
      });
      startMenu.appendChild(startButton);
      document.body.appendChild(startMenu);
  }

  // LUMIERE AMBIANTE ROUGE (faible) GLOBALE
  const redAmbient = new THREE.AmbientLight(0xff0000, 0.02);
  scene.add(redAmbient);

  // SHADERS
  const redGlowVertexShader = `
    varying vec2 vUv;
    varying vec3 vPosition;
    varying vec3 vNormal;
    void main() {
      vUv = uv;
      vPosition = position;
      vNormal = normalize(normalMatrix * normal);
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;
  const redGlowFragmentShader = `
    uniform float time;
    uniform float glow;
    varying vec2 vUv;
    varying vec3 vPosition;
    varying vec3 vNormal;
    void main() {
      vec4 color = vec4(1.0, 0.0, 0.0, 0.7);
      float pulse = 0.5 + 0.5 * sin(time * 2.0);
      float fresnel = pow(1.0 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
      color.rgb += vec3(0.7, 0.0, 0.0) * fresnel * glow * pulse;
      gl_FragColor = color;
    }
  `;

  // TEXTURES SOL & MURS
  const textureLoader = new THREE.TextureLoader();
  textureLoader.load('./assets/textures/floor_bump.jpg', function(floorTexture) {
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping;
    floorTexture.repeat.set(4, 20);
    if (!(ground.material instanceof THREE.MeshStandardMaterial)) {
      const oldColor = ground.material.color;
      ground.material = new THREE.MeshStandardMaterial({
        color: oldColor,
        roughness: 0.4,
        metalness: 0.2
      });
    }
    ground.material.normalMap = floorTexture;
    ground.material.normalScale.set(0.8, 0.8);
    console.log("Normal map applied to floor");
  });
  textureLoader.load('./assets/textures/bump.jpg', function(texture) {
    texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    Object.entries(walls).forEach(([direction, { visualWall }]) => {
      const wallTexture = texture.clone();
      if (direction === 'left' || direction === 'right') {
        wallTexture.repeat.set(1, 20);
        wallTexture.rotation = Math.PI / 2;
        wallTexture.center.set(0.5, 0.5);
      } else {
        wallTexture.repeat.set(5, 1);
      }
      if (!(visualWall.material instanceof THREE.MeshStandardMaterial)) {
        const oldColor = visualWall.material.color;
        visualWall.material = new THREE.MeshStandardMaterial({
          color: oldColor,
          roughness: 0.7,
          metalness: 0.3
        });
      }
      visualWall.material.normalMap = wallTexture;
      visualWall.material.normalScale.set(1.5, 1.5);
      visualWall.castShadow = true;
      visualWall.receiveShadow = true;
    });
    console.log("Normal maps applied to walls");
  });

  // SCORE
  let score = 0;
  let scoreInterval = null;
  const scoreDisplay = document.createElement('div');
  scoreDisplay.style.cssText = `
    position: fixed;
    top: 20px;
    left: 20px;
    padding: 10px 20px;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    font-size: 18px;
    font-family: Arial, sans-serif;
    border-radius: 5px;
    z-index: 1000;
  `;
  scoreDisplay.textContent = `Score: 0`;
  document.body.appendChild(scoreDisplay);

  function startScoreCounter() {
    score = 0;
    if (scoreInterval) clearInterval(scoreInterval);
    scoreInterval = setInterval(() => {
      score += 1;
      scoreDisplay.textContent = `Score: ${score}`;
    }, 100);
  }

  function stopScoreCounter() {
    if (scoreInterval) clearInterval(scoreInterval);
  }

</script>
</body>
</html>
